= Writing an FFI interface to NCurses

- helps to know the library you're converting

== Interpreting ncurses.h

/usr/include/ncurses.h on my Ubuntu system

Starts with standard protection against double inclusion

There are 333 functions defined as NCURSES_EXPORT
and 12 exported variables.

IMHO that is far more than are needed to provide a portable terminal
library but who cares what I think?

OK - so I've committed to porting this library. It looks like quite a
lot of work. So, it would be a good idea to find some way to cut down
on the donkey work.

The first step is to get a lay of the land and see exactly what the
task will involve.

One thing to note is that most of the functions that operate on the
stdscr are defined as macros. Obviously, those won't be exported so
we'll have to define our own methods to emulate them.

The function signatures have a number of patterns depending on how
many arguments they take and whether they return anything.

- void fn(void) - a fn taking no arguments and returning nothing -
  these are commands that can return no useful information
- int fn(void) a fn taking no arguments and returning an integer -

= return value patterns

void :: no return value 

== scalar values

int :: these are either informational functions (e.g. getcury),
commands that return a status code (savetty), functions that return
input data (getch) or functions that convert input (COLOR_PAIR)

bool :: predicate functions (can_change_color, is_wintouched)

chtype :: functions that return an ncurses character value

char :: functions returning a C character value (killchar)

attr_t :: functions returns an ncurses attribute value

mmask_t :: function returning a mouse mask value (mousemask)

== pointers

WINDOW * :: functions that return a pointer to a WINDOW struct
(dupwin) - this maps to :pointer

NCURSES_CONST char * :: functions returning a constant string
(keyname) - this maps to :string

(const) char * :: functions returning a C string pointer (termname)

SCREEN * :: pointer to a new terminal structure

Luckily for us, the char * return values map onto Ruby FFI :string and
WINDOW* and SCREEN* are essentially tokens for opaque structs (like
FILE*), so we can pass them around as :pointer without caring what's inside.

= Arguments

The most important argument types are:

- chtype
- int
- WINDOW *
- NCURSES_ATTR_T
- attr_t
- short

with these, we can get a long way.

== Handling values returned through pointer arguments

However, sooner or later, we're going to have to deal with pointer
arguments which do not represent opaque data structures generated by
ncurses itself. C does not support multiple return values so to return
more than one piece of data, you use pointers to buffers set up before
the function call.

A typical example in the ncurses lib is attr_get. In ncurses.h, it has
this signature:

  extern NCURSES_EXPORT(int) attr_get (attr_t *, short *, void *);

Referring to the man page (man attr_get), we find:

  int attr_get(attr_t *attrs, short *pair, void *opts);
  ...
  attr_get returns the current attribute and color pair

Now, there is no way of knowing in C from an argument declaration
whether we will receive one or more elements via that pointer. Despite
the plural name (attrs) it appears from the source that it really is
only one value (but called attrs because it specifies both the
foreground and background attributes).

BTW, that final argument (*opts) is never used - you should always
pass nil in Ruby (NULL in C) both here and in the
corresponding attr_set function (and everywhere *opts is
specified). It is 'reserved for future use'.  I'm sure it seemed like
a good idea at the time... A good example of YAGNI.

To work with these, we need FFI's MemoryPointer.

= Structs

== MEVENT

Mouse event. If we want to support mice, we need to set up and receive
the MEVENT struct.

ffi makes this easy. Just define the struct:

  class MEVENT < FFI::Struct
    layout :id, :short,
    :x, :int,
    :y, :int,
    :z, :int,
    :bstate, :ulong
  end

specify which functions require a pointer to it:

  attach_function :getmouse, [MEVENT], :int
  attach_function :ungetmouse, [MEVENT], :int

allocate it before use:

  mouse_event = MEVENT.new

call the function:

  if getmouse(mouse_event) == NCurses::OK

and check the results:

  if mouse_event[:bstate] & NCurses::BUTTON1_PRESSED

== cchar_t
There is only one other non-opaque data structure, cchar_t which is only
used in ncurses debugging with XOPEN_SOURCE_EXTENDED, so we won't
worry about it just now.

= Comments

C-style comments

  /* this is a comment */

  /* 
   *  this is a multi-line
   *  comment 
   */

get translated to Ruby-style:

  # this is a comment

  # this is a multi-line
  # comment 
  
= Constants and macros (#defines)

Most constants can be mechanically translated, e.g.

  #define KEY_DOWN  0402   /* down-arrow key */

becomes

  KEY_DOWN = 0402 # down-arrow key

This is so trivial I did it in emacs. However, it might be worthwhile
to knock up a simple 80/20 util to automate it.

I have transliterated macros as closely as possible to the
original. So this means very unrubyish code (e.g. method names in
ALL_CAPS and C-like bit twiddling). The reason is to stay as close as
possible to the source. It's a lot easier to track down problems if
the mapping is almost one-to-one.

Some definitions are dependent on macros. In that case, I have defined
the macros as module methods.

Conditional compilation like this:

  #if NCURSES_MOUSE_VERSION > 1
  #define NCURSES_MOUSE_MASK(b,m) ((m) << (((b) - 1) * 5))
  #else
  #define NCURSES_MOUSE_MASK(b,m) ((m) << (((b) - 1) * 6))
  #endif

does not exist in the same way in Ruby. Instead, we can check at
runtime.

Here is an excerpt from the mouse handling code that shows these
transliterations.

  #if NCURSES_MOUSE_VERSION > 1
  #define NCURSES_MOUSE_MASK(b,m) ((m) << (((b) - 1) * 5))
  #else
  #define NCURSES_MOUSE_MASK(b,m) ((m) << (((b) - 1) * 6))
  #endif

  #define	NCURSES_BUTTON_RELEASED	001L
  /* [snip] */

  /* event masks */
  #define	BUTTON1_RELEASED	NCURSES_MOUSE_MASK(1, NCURSES_BUTTON_RELEASED)

becomes this:

  if NCURSES_MOUSE_VERSION > 1
    def self.NCURSES_MOUSE_MASK(b,m)
      ((m) << (((b) - 1) * 5))
    end
  else
    def self.NCURSES_MOUSE_MASK(b,m)
      ((m) << (((b) - 1) * 6))
    end
  end

  NCURSES_BUTTON_RELEASED	= 001
  # [snip]

  # event masks 
  BUTTON1_RELEASED        = NCURSES_MOUSE_MASK(1, NCURSES_BUTTON_RELEASED)

= Variadic functions

Variadic functions are those taking an variable number of arguments
(monadic = 1, dyadic = 2, triadic = 3, variadic = variable). In C,
they are implemented using the varargs protocol.

The C function declaration:

  extern NCURSES_EXPORT(int) printw (const char *,...)
		GCC_PRINTFLIKE(1,2);

reduced to its essentials looks like this

  int printw (const char *,...);

That '...', called an ellipsis, denotes that this function takes a
variable number of arguments.

Declaring this function in ffi is easy:

  attach_function :printw, [:string, :varargs], :int

Using it is slightly more involved.

The main thing to remember with variadic functions is that Ruby has no
way of automatically figuring out which C-type any particular argument
should be translated to. This means you have to specify the C-types
when you pass in the optional args.

For example:

  NCurses.printw("Hello %s! There are %d arguments to this variadic function!", :string, "world", :int, 2)

(TODO: Where are the possible types defined in ffi?).

= Typedefs

It might be tempting to use FFI.typedef to define your own types. My
advice would be don't. They are not namespaced so you cannot restrict
the typedef to your own FFI. The chances of conflicting with another
definition are too great and all too likely.

Instead, define your own type aliases as constants and refer to those,
e.g. NCURSES_ATTR_T = :uint.

= 32 vs 64 bits

TODO: address 32 vs 64 bit.

= Exported globals

There is no obvious way to access exported globals using FFI.

= Let's get going

2008-11-17 17:01:06

Turns out the way to dereference variables is to - guess what? -
dereference them! I'm such a dope. You need to do sthg like:

  pp_stdscr = DL.dlsym(handle, 'stdscr')
  pp_curscr = DL.dlsym(handle, 'curscr')
  p_stdscr = pp_stdscr.read_pointer
  p_curscr = pp_curscr.read_pointer

Would be handy to incorporate this into FFI - attach_variable (and
corresponding attach_constant/global for shared globals which would
not do the double dereference). In particular, would be good to ensure
that we are using the same DLL handle.

Python's ctypes library has lots of nice touches - especially all the
special-case Win32 stuff.

One thing I'm a little baffled by at the moment - I can't define a
signature containing :short - but it does seem to be defined as a type
and works when you FFI.find_type(:short). :int8 works on those
functions. What am I missing here?

I'm also wondering how much of FFI could be done in Ruby with just the
libffi and dl functions?

Note - need to unpack attr_t *attrs and short *pairs

= Compile ruby-ffi from source on Mac OS X

$ sudo port install mercurial
$ hg clone https://kenai.com/hg/ruby-ffi~mercurial 

= Testing

- I don't want to test ncurses
- I want to test that my Ruby wrapper produces equivalent results to
  the same program written using the C API
- I need to test output to a terminal
- This can be different depending on which terminal is actually used
- So...
- ...the only way I can think of is to compare the output from a
  program written in C and the equivalent program written in Ruby
- but how do I ensure that both programs really are equivalent
- generate from common source
- how?
- by using a DSL that can be used to generate both programs

- see testdsl branch (in directory testdsl/) for a start on this idea

= NCurses Versions
- these are the ncurses versions I know about
  - Mac OS X 10.4
  - Ubuntu 8.04
  - PDcurses-3.3 (XCurses) 

= Mouse handling

- different under Linux console and, say, gnome-terminal or xterm
  - under X you need to specify keypad(stdscr, 1) to get KEY_MOUSE
    code reported
- BUTTON_PRESS1 is not reported unless you hold down the mouse button
- a normal click is reported as a BUTTON_CLICK



