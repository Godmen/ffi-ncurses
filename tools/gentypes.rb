#!/usr/bin/env ruby -w

# quick and dirty hack to generate function signatures for ruby-ffi
# from ncurses.h

require 'rubygems'
require 'pp'
require 'ffi'

signatures = []
filename = ARGV[0] || '/usr/include/ncurses.h'

# the abstract _p types can be changed to :pointer (= void *)
no_types = true
if no_types
  NCURSES_ATTR_T = :uint
  ATTR_T = :uint
  ATTR_T_P = :pointer
  SCREEN_P = :pointer
  WINDOW_P = :pointer
  CHTYPE = :uint
  MEVENT_P = :pointer
  CHTYPE_P = :pointer
  INT_P = :pointer
  CCHAR_T_P = :pointer
  FILE_P = :pointer
  MMASK_T = :uint
  MMASK_T_P = :pointer
  SHORT_P = :pointer
  BOOLEAN = :int
else
  NCURSES_ATTR_T = :attr_t
  ATTR_T = :attr_t
  ATTR_T_P = :attr_t_p
  SCREEN_P = :screen_p
  WINDOW_P = :window_p
  CHTYPE = :chtype
  CHTYPE_P = :chtype_p
  MEVENT_P = :mevent_p
  INT_P = :int_p
  CCHAR_T_P = :cchar_t_p
  FILE_P = :file_p
  MMASK_T = :mmask_t
  MMASK_T_P = :mmask_t_p
  SHORT_P = :short_p
  BOOLEAN = :bool
end

@typemap = {
  "..." => :varargs,
  "FILE*" => FILE_P,
  "MEVENT*" => MEVENT_P,
  "NCURSES_ATTR_T" => NCURSES_ATTR_T,
  "SCREEN*" => SCREEN_P,
  "WINDOW*" => WINDOW_P,
  "attr_t" => ATTR_T,
  "attr_t*" => ATTR_T_P,       #
  "bool" => BOOLEAN,
  "_Bool" => BOOLEAN,
  "cchar_t*" => CCHAR_T_P,     # wide character support - cchar_t is a struct
  "char" => :char,
  "char*" => :string,
  "chtype" => CHTYPE,
  "chtype*" => CHTYPE_P,       #
  "int" => :int,
  "int*" => INT_P,             #
  "long" => :long,
  "mmask_t" => MMASK_T,
  "mmask_t*" => MMASK_T_P,     #
  "short" => :short,
  "short*" => SHORT_P,         #
  "unsigned int" => :uint,
  "va_list" => [:unmapped, :va_list],
  "void" => :void,
  "void*" => :pointer,
}

def map_type(t)
  t = t.gsub(/(NCURSES_)?CONST/i,'').strip.gsub(/\s+\*/, '*')
  @typemap.key?(t) ? @typemap[t] : [:unmapped, t]
end

# these patterns are specific to the ncurses.h include file
RX_RETURN_TYPE = '\\(.*?\\)'
RX_IDENTIFIER = '[A-Za-z_][A-Za-z_0-9]*'
RX_ARGS = "\\((.*?)\\)"
RX_BRACKETS = '[()]'
# RX_EXPORT = 'extern\\s+((NCURSES_)?EXPORT)?'
RX_EXPORT = 'extern'

line_counter = 0
IO.readlines(filename).each do |line|
  begin
    line_counter += 1
    if line =~ /#{RX_EXPORT}.*\(/i
      txt = line.gsub(/#{RX_EXPORT}/i, '').strip
      #p [:txt, txt]
      # return_type = txt.match(/(#{RX_RETURN_TYPE})/).captures[0]

      args = txt.match(RX_ARGS)
      if args
        args = args.captures[0]
        args = args.gsub(/#{RX_BRACKETS}/, '').split(/\s*,\s*/).map{|x| map_type(x)}
      else
        STDERR.puts "No args"
      end
      #p [:args, args]
      txt = txt.gsub(/\s*#{RX_ARGS}\s*;?\s*$/, '')
      #p [:txt, txt]

      tokens = txt.split
      method_name = tokens[-1]
      return_type = tokens[0..-2].join(" ")
      #p [:return_type, return_type]
      return_type = return_type.gsub(/#{RX_BRACKETS}/, '')
      return_type = return_type.gsub(/\s+\*/, '*')
      return_type = map_type(return_type)
      #p [:return_type_mapped, return_type]

      signatures << [method_name.to_sym, args == [:void] ? [] : args, return_type]
    else
      STDERR.puts "skipping line: #{line}"
    end
  rescue => e
    #p [:exception, e, :line, line_counter, line]
  end
end

# discard sigs of functions we can't handle
unmapped, sigs = signatures.partition{ |s| s.flatten.include?(:unmapped)}
puts "
  # this list of function signatures was generated by the file
  # generate-ffi-ncurses-function-signatures.rb and inserted here by hand
  functions =
    [
      #{ sigs.sort_by { |x| x.to_s }.map{ |sig| sig.inspect }.join(",\n      ") }
    ]
  # end of autogenerated function list
"

STDERR.puts "# unmapped functions"
STDERR.puts unmapped.sort_by{ |x| x.to_s }.pretty_inspect

#puts "# #{sigs.size}"
#puts "# #{unmapped.size}"
