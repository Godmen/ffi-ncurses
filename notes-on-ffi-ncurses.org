= Writing an FFI interface to NCurses

- helps to know the library you're converting

== Interpreting ncurses.h

/usr/include/ncurses.h on my Ubuntu system

Starts with standard protection against double inclusion

There are 333 functions defined as NCURSES_EXPORT
and 12 exported variables.

IMHO that is far more than are needed to provide a portable terminal
library but who cares what I think?

OK - so I've committed to porting this library. It looks like quite a
lot of work. So, it would be a good idea to find some way to cut down
on the donkey work.

The first step is to get a lay of the land and see exactly what the
task will involve.

One thing to note is that most of the functions that operate on the
stdscr are defined as macros. Obviously, those won't be exported so
we'll have to define our own methods to emulate them.

The function signatures have a number of patterns depending on how
many arguments they take and whether they return anything.

- void fn(void) - a fn taking no arguments and returning nothing -
  these are commands that can return no useful information
- int fn(void) a fn taking no arguments and returning an integer -

= return value patterns

void :: no return value 

== scalar values

int :: these are either informational functions (e.g. getcury),
commands that return a status code (savetty), functions that return
input data (getch) or functions that convert input (COLOR_PAIR)

bool :: predicate functions (can_change_color, is_wintouched)

chtype :: functions that return an ncurses character value

char :: functions returning a C character value (killchar)

attr_t :: functions returns an ncurses attribute value

mmask_t :: function returning a mouse mask value (mousemask)

== pointers

WINDOW * :: functions that return a pointer to a WINDOW struct
(dupwin) - this maps to :pointer

NCURSES_CONST char * :: functions returning a constant string
(keyname) - this maps to :string

(const) char * :: functions returning a C string pointer (termname)

SCREEN * :: pointer to a new terminal structure

Luckily for us, the char * return values map onto Ruby FFI :string and
WINDOW* and SCREEN* are essentially tokens for opaque structs (like
FILE*), so we can pass them around as :pointer without caring what's inside.

= Arguments

The most important argument types are:

- chtype
- int
- WINDOW *
- NCURSES_ATTR_T
- attr_t
- short

with these, we can get a long way.

== Handling values returned through pointer arguments

However, sooner or later, we're going to have to deal with pointer
arguments which do not represent opaque data structures generated by
ncurses itself. C does not support multiple return values so to return
more than one piece of data, you use pointers to buffers set up before
the function call.

A typical example in the ncurses lib is attr_get. In ncurses.h, it has
this signature:

  extern NCURSES_EXPORT(int) attr_get (attr_t *, short *, void *);

Referring to the man page (man attr_get), we find:

  int attr_get(attr_t *attrs, short *pair, void *opts);
  ...
  attr_get returns the current attribute and color pair

Now, there is no way of knowing in C from an argument declaration
whether we will receive one or more elements via that pointer. Despite
the plural name (attrs) it appears from the source that it really is
only one value (but called attrs because it specifies both the
foreground and background attributes).

BTW, that final argument (*opts) is never used - you should always
pass 0 (which is a NULL pointer in C) both here and in the
corresponding attr_set function (and everywhere *opts is
specified). It is 'reserved for future use'.  I'm sure it seemed like
a good idea at the time... A good example of YAGNI.

To work with these, we need FFI's MemoryPointer.

= Structs

== MEVENT

Mouse event. If we want to support mice, we need to get to grips with
how to set up and receive structures.

== cchar_t
There is only one other non-opaque data structure, cchar_t which is only
used in ncurses debugging with XOPEN_SOURCE_EXTENDED, so we won't
worry about it just now.

= Constants and macros (#defines)

= Notes on ncurses

- doesn't surprise me 00000001 that ncurses 5.7 fails to compile on Ubuntu 8.10

== naming is dreadful 
- there is attron and attr_on (taking different args)
- mixture of object_verb, objectverb, verbobject and verb_object (curs_set,
  bkgdset, copywin, init_color)
- insnstr, insstr, instr
- addch, waddch, mvaddch, mvwaddch - there is a certain logic to this,
  but it's completely unnecessary - addch is either a macro or
  function that calls waddch with stdscr as the first parameter and
  there is little or nothing gained in terms of program efficiency
  from combining move and addch and way too much cognitive
  overload. IMHO an example of a very poor API design.

- A more modern API (i.e. circa 1985) would probably look something like this:

    ncurses_window_move(window, row, col);
    ncurses_window_putc(window, char);
    ncurses_window_move_putc(window, row, col, char);
    etc.

  completely eschewing the functions operating on stdscr.

== historical baggage

== Old-school C coding style

= Variadic functions

Variadic functions are those taking an variable number of arguments
(monadic = 1, dyadic = 2, triadic = 3, variadic = variable). In C,
they are implemented using the varargs protocol.

= Typedefs

It might be tempting to use FFI.typedef to define your own types. My
advice would be don't. They are not namespaced so you cannot restrict
the typedef to your own FFI. The chances of conflicting with another
definition are too great and all too likely.

Instead, define your own type aliases as constants and refer to those,
e.g. NCURSES_ATTR_T = :uint.

TODO: address 32 vs 64 bit.

= Exported globals

There is no obvious way to access exported globals using FFI.

= Let's get going

2008-11-17 17:01:06

Turns out the way to dereference variables is to - guess what? -
dereference them! I'm such a dope. You need to do sthg like:

  pp_stdscr = DL.dlsym(handle, 'stdscr')
  pp_curscr = DL.dlsym(handle, 'curscr')
  p_stdscr = pp_stdscr.read_pointer
  p_curscr = pp_curscr.read_pointer

Would be handy to incorporate this into FFI - attach_variable (and
corresponding attach_constant/global for shared globals which would
not do the double dereference). In particular, would be good to ensure
that we are using the same DLL handle.

Python's ctypes library has lots of nice touches - especially all the
special-case Win32 stuff.

One thing I'm a little baffled by at the moment - I can't define a
signature containing :short - but it does seem to be defined as a type
and works when you FFI.find_type(:short). :int8 works on those
functions. What am I missing here?

I'm also wondering how much of FFI could be done in Ruby with just the
libffi and dl functions?

Note - need to unpack attr_t *attrs and short *pairs


= Compile on Ubuntu 8.10

$ sudo apt-get install libffi-dev


= Compile ruby-ffi from source on Mac OS X

$ sudo port install mercurial
$ hg clone https://kenai.com/hg/ruby-ffi~mercurial 

= Testing

- I don't want to test ncurses
- I want to test that my Ruby wrapper produces equivalent results to
  the same program written using the C API
- I need to test output to a terminal
- This can be different depending on which terminal is actually used
- So...
- ...the only way I can think of is to compare the output from a
  program written in C and the equivalent program written in Ruby
- but how do I ensure that both programs really are equivalent
- generate from common source
- how?
- by using a DSL that can be used to generate both programs

